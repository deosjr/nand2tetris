var sif string
var sdefine string
var sbegin string
var sadd string
var ssub string
var smul string
var sgt string
var slt string

func init() {
    env.init()
    parser.init()
    sif = "if"
    sdefine = "define"
    sbegin = "begin"
    sadd = "+"
    ssub = "-"
    smul = "*"
    sgt = ">"
    slt = "<"
    return
}

func eval(x sexpr) sexpr {
    e := env.global()
    return lisp.evalEnv(x, e)
}

func evalEnv(x sexpr, env env) any {
    t := x.typ
    m := env.m
    // variable reference
    if t == 0 { // symbol
        return m.search(x.value)
    }
    // constant number
    if t == 1 { // number
        return x.value
    }
    op := x.left
    var opstr string
    opstr = op.value
    args := x.right
    // conditional
    if opstr.equals(sif) {
        test := args.left
        args = args.right
        conseq := args.left
        args = args.right
        alt := args.left
        if lisp.evalEnv(test, env) {
            return lisp.evalEnv(conseq, env)
        }
        return lisp.evalEnv(alt, env)
    }
    // definition
    if opstr.equals(sdefine) {
        symbol := args.left
        args = args.right
        // exp = args.left
        exp := lisp.evalEnv(args.left, env)
        m.insert(symbol.value, exp)
        return 0
    }
    // procedure call
    len := args.length()
    values := array.new(len)
    for i:=0; i<len; i++ {
        values[i] = lisp.evalEnv(args.left, env)
        args = args.right
    }
    // first hardcoded ones (easier than adding in globalenv)
    if opstr.equals(sadd) {
        return values[0] + values[1]
    }
    if opstr.equals(ssub) {
        return values[0] - values[1]
    }
    if opstr.equals(smul) {
        return values[0] * values[1]
    }
    if opstr.equals(sgt) {
        return values[0] > values[1]
    }
    if opstr.equals(slt) {
        return values[0] < values[1]
    }
    if opstr.equals(sbegin) {
        return values[len-1]
    }
    // then user-defined procedures
    proc := lisp.evalEnv(op, env)
    return 0
}

func parse(program string) sexpr {
    var tokens list
    tokens = parser.tokenize(program)
    var p parser
    p := parser.new(tokens)
    s := p.parse()
    p.dispose()
    return s
}

