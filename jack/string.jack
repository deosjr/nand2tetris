type string struct {
    length int
    arr  array
}

func new(maxlen int) string {
    maxlen = maxlen + 1
    maxlen = maxlen / 2
    s := string{}
    s.length = 0
    s.arr = array.new(maxlen)
    return s
}

func (s string) dispose() {
    memory.dealloc(s.arr)
    memory.dealloc(s)
    return
}

func (s string) length() int {
    return s.length
}

func (s string) charAt(j int) char {
    i := j / 2
    x := s.arr[i]
    even := j & 1
    // abusing truthy: if integer means if integer is not 0
    // this means !even does _not_ work as you might expect
    if even {
        return x & 0x00ff
    }
    x = x << 8
    return x & 0x00ff
}

func (s string) setCharAt(j int, c char) {
    i := j / 2
    x := s.arr[i]
    even := j & 1
    if even {
        x = x << 8
    }
    c = c << 8
    x = x & 0x00ff
    x = x | c
    if even {
        s.arr[i] = x << 8
        return
    }
    s.arr[i] = x
    return
}

func (s string) appendChar(c char) string {
    s.setCharAt(s.length, c)
    s.length = s.length + 1
    return s
}

func (s string) eraseLastChar() {
    s.length = s.length - 1
    return
}

func (s string) print() {
    for j:=0; j<s.length; j++ {
        print(s.charAt(j))
    }
    return
}

func (s string) equals(ss string) bool {
    x := s.compare(ss)
    return x == 0
}

// return -1 if s<ss, 0 if s==ss, 1 if s>ss
// using true instead of -1 as that overflows constant...
// NOTE we can compare two chars at a time now!
func (s string) compare(ss string) int {
    min := s.length
    if s.length > ss.length {
        min = ss.length
    }
    min = min + 1
    min = min / 2
    for j:=0; j<min; j++ {
        d := s.arr[j] - ss.arr[j]
        if d < 0 {
            return true
        }
        if d > 0 {
            return 1
        }
    }
    if s.length < ss.length {
        return true
    }
    if ss.length < s.length {
        return 1
    }
    return 0
}
