// (eval env e) -> evaluation of e in env, or NIL if error
// NOTE env is an argument, not ENV.
// TODO: if first argument is not an env assoc list (how?), use *ENV instead
function eval
    push constant 0     // prepare local 0 = e
    push constant 0     // prepare local 1 = evaluated procedure
    push constant 0     // prepare local 2 = num args
    push argument
    cdr
    car
    pop local 0         // store e in lcl0
    push local 0
    is-procedure
    if-goto evalself
    push local 0
    is-symbol
    if-goto evalsymbol
    push local 0
    is-primitive
    if-goto evalself
    // guaranteed to be a pair!
label evalpair
    push argument
    car         // env on the stack
    push local 0
    car
    push constant 8192  // 0x2000 = emptylist
    cons
    cons
    call eval.eval
    pop local 1
    push local 1        // evalled procedure
    is-procedure
    if-goto evalprocedure
    // attempt to apply non-procedure
    goto sys.end
label evalself
    push local 0
    return
label evalsymbol
    push argument
    call assoc.assq
    pop local 2
    push local 2
    push constant 0
    eq
    // symbol not found
    if-goto sys.end
    push local 2
    return
label evalprocedure
    push local 1
    is-special
    if-goto evalspecial
label evalargs
    // we will need to build ( evaluatedargs ... )
    // on the stack, then call the evaluated func with those args
    push local 0
    cdr
    // if emptylist, we ran out of args
    is-emptylist
    if-goto evalfunc
    push local 2
    push constant 1
    add
    pop local 2     // numargs++
    push local 0
    cdr
    pop local 0
    push argument
    car             // env on the stack
    push local 0
    car
    push constant 8192  // 0x2000 = emptylist
    cons
    cons
    call eval.eval  // returns evalled arg, or NIL if error
    goto evalargs
label evalfunc
    push constant 8192  // 0x2000 = emptylist
// cons numargs times
label consloop
    push constant 0
    push local 2
    eq
    if-goto call
    cons
    push local 2
    push constant 1
    sub
    pop local 2
    goto consloop
// actually call the function stored in local 1
label call
    push local 1
    call-builtin
    return
label evalspecial
    // remove mask
    push local 1
    push constant 8191  // 0x1fff
    and
    pop local 1
    push local 1
    push constant 0
    eq
    if-goto evalif
    push local 1
    push constant 1
    eq
    if-goto evaldefine
    push local 1
    push constant 2
    eq
    if-goto evalquote
    // unknown builtin, return err
    goto sys.end
label evalif
    push argument
    car                 // env on the stack
    push local 0
    cdr
    car                 // test
    push constant 8192  // 0x2000 = emptylist
    cons
    cons
    call eval.eval
    push constant 0
    equal
    if-goto evalalt
// label evalconseq
    push argument
    car                 // env on the stack
    push local 0
    cdr
    cdr
    car                 // conseq
    push constant 8192  // 0x2000 = emptylist
    cons
    cons
    call eval.eval
    return
label evalalt
    push argument
    car                 // env on the stack
    push local 0
    cdr
    cdr
    cdr
    car                 // alt
    push constant 8192  // 0x2000 = emptylist
    cons
    cons
    call eval.eval
    return
label evaldefine
    // TODO: this just adds, doesnt check if already exists in env
    push local 0
    cdr 
    car                 // symbol
    // TODO: if not symbol, error!
    push argument
    car                 // env on the stack
    push local 0
    cdr
    cdr
    car                 // exp
    push constant 8192  // 0x2000 = emptylist
    cons
    cons
    call eval.eval
    cons                // (symbol . (eval exp))
    push environment
    cons
    // TODO: we need to repoint for any stored pointers
    // OR do we? Might happen automagically in sys.return!
    pop environment     // cons onto existing env
    push constant 0
    return
label evalquote
    push local 0
    cdr
    car
    return
